[
  {
    "type": "session.updated",
    "properties": {
      "info": {
        "slug": "happy-harbor",
        "time": { "created": 1769437845874, "updated": 1769437845874 },
        "projectID": "29d43526f88157cd4edd071b899dd01f240b771b",
        "id": "ses_40549268dffehKpDd14uHIMQaT",
        "version": "1.1.31",
        "title": "New session - 2026-01-26T14:30:45.874Z",
        "directory": "/home/francis/Projects/_nvim/opencode.nvim"
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.updated",
    "properties": {
      "info": {
        "id": "msg_bfab6dbf3001ZOVHTFKR1CMUE5",
        "time": { "created": 1769437846515 },
        "role": "user",
        "agent": "build",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "model": { "providerID": "github-copilot", "modelID": "gpt-4.1" }
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "type": "text",
        "text": "Called the Read tool with the following input: {\"filePath\":\"/home/francis/Projects/_nvim/opencode.nvim/tests/replay/renderer_spec.lua\"}",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "messageID": "msg_bfab6dbf3001ZOVHTFKR1CMUE5",
        "id": "prt_bfab6dbf4002ydMd2JojY4Nda0",
        "synthetic": true
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "type": "text",
        "text": "<file>\n00001| local state = require('opencode.state')\n00002| local ui = require('opencode.ui.ui')\n00003| local helpers = require('tests.helpers')\n00004| local output_window = require('opencode.ui.output_window')\n00005| local assert = require('luassert')\n00006| local config = require('opencode.config')\n00007| \n00008| local function assert_output_matches(expected, actual, name)\n00009|   local normalized_extmarks = helpers.normalize_namespace_ids(actual.extmarks)\n00010| \n00011|   assert.are.equal(\n00012|     #expected.lines,\n00013|     #actual.lines,\n00014|     string.format(\n00015|       'Line count mismatch: expected %d, got %d.\\nFirst difference at index %d:\\n  Expected: %s\\n  Actual: %s',\n00016|       #expected.lines,\n00017|       #actual.lines,\n00018|       math.min(#expected.lines, #actual.lines) + 1,\n00019|       vim.inspect(expected.lines[math.min(#expected.lines, #actual.lines) + 1]),\n00020|       vim.inspect(actual.lines[math.min(#expected.lines, #actual.lines) + 1])\n00021|     )\n00022|   )\n00023| \n00024|   for i = 1, #expected.lines do\n00025|     assert.are.equal(\n00026|       expected.lines[i],\n00027|       actual.lines[i],\n00028|       string.format(\n00029|         'Line %d mismatch:\\n  Expected: %s\\n  Actual: %s',\n00030|         i,\n00031|         vim.inspect(expected.lines[i]),\n00032|         vim.inspect(actual.lines[i])\n00033|       )\n00034|     )\n00035|   end\n00036| \n00037|   assert.are.equal(\n00038|     #expected.extmarks,\n00039|     #normalized_extmarks,\n00040|     string.format(\n00041|       'Extmark count mismatch: expected %d, got %d.\\nFirst difference at index %d:\\n  Expected: %s\\n  Actual: %s',\n00042|       #expected.extmarks,\n00043|       #normalized_extmarks,\n00044|       math.min(#expected.extmarks, #normalized_extmarks) + 1,\n00045|       vim.inspect(expected.extmarks[math.min(#expected.extmarks, #normalized_extmarks) + 1]),\n00046|       vim.inspect(normalized_extmarks[math.min(#expected.extmarks, #normalized_extmarks) + 1])\n00047|     )\n00048|   )\n00049| \n00050|   for i = 1, #expected.extmarks do\n00051|     assert.are.same(\n00052|       expected.extmarks[i],\n00053|       normalized_extmarks[i],\n00054|       string.format(\n00055|         'Extmark %d mismatch:\\n  Expected: %s\\n  Actual: %s',\n00056|         i,\n00057|         vim.inspect(expected.extmarks[i]),\n00058|         vim.inspect(normalized_extmarks[i])\n00059|       )\n00060|     )\n00061|   end\n00062| \n00063|   local expected_action_count = expected.actions and #expected.actions or 0\n00064|   local actual_action_count = actual.actions and #actual.actions or 0\n00065| \n00066|   assert.are.equal(\n00067|     expected_action_count,\n00068|     actual_action_count,\n00069|     string.format('Action count mismatch: expected %d, got %d', expected_action_count, actual_action_count)\n00070|   )\n00071| \n00072|   if expected.actions then\n00073|     -- Sort both arrays for consistent comparison since order doesn't matter\n00074|     local function sort_actions(actions)\n00075|       local sorted = vim.deepcopy(actions)\n00076|       table.sort(sorted, function(a, b)\n00077|         return vim.inspect(a) < vim.inspect(b)\n00078|       end)\n00079|       return sorted\n00080|     end\n00081| \n00082|     assert.same(\n00083|       sort_actions(expected.actions),\n00084|       sort_actions(actual.actions),\n00085|       string.format(\n00086|         'Actions mismatch:\\n  Expected: %s\\n  Actual: %s',\n00087|         vim.inspect(expected.actions),\n00088|         vim.inspect(actual.actions)\n00089|       )\n00090|     )\n00091|   end\n00092| end\n00093| \n00094| describe('renderer unit tests', function()\n00095|   local event_subscriptions = {\n00096|     'session.updated',\n00097|     'session.compacted',\n00098|     'session.error',\n00099|     'message.updated',\n00100|     'message.removed',\n00101|     'message.part.updated',\n00102|     'message.part.removed',\n00103|     'permission.updated',\n00104|     'permission.replied',\n00105|     'question.replied',\n00106|     'question.asked',\n00107|     'file.edited',\n00108|     'custom.restore_point.created',\n00109|     'custom.emit_events.finished',\n00110|   }\n00111| \n00112|   before_each(function()\n00113|     require('opencode.event_manager').setup()\n00114|   end)\n00115| \n00116|   it('subsribes to events correctly', function()\n00117|     local renderer = require('opencode.ui.renderer')\n00118|     local event_manager = state.event_manager\n00119| \n00120|     event_manager.events = {}\n00121| \n00122|     renderer.setup_subscriptions()\n00123| \n00124|     for _, event_name in ipairs(event_subscriptions) do\n00125|       assert.is_true(\n00126|         event_manager.events[event_name] ~= nil,\n00127|         string.format('Renderer did not subscribe to event: %s', event_name)\n00128|       )\n00129|     end\n00130|   end)\n00131| \n00132|   it('unsubsribes from events correctly', function()\n00133|     local renderer = require('opencode.ui.renderer')\n00134|     local event_manager = state.event_manager\n00135| \n00136|     renderer.setup_subscriptions()\n00137| \n00138|     renderer.setup_subscriptions(false)\n00139| \n00140|     for _, event_name in ipairs(event_subscriptions) do\n00141|       assert.is_true(\n00142|         vim.tbl_isempty(event_manager.events[event_name]),\n00143|         string.format('Renderer did not unsubscribe from event: %s', event_name)\n00144|       )\n00145|     end\n00146|   end)\n00147| end)\n00148| \n00149| describe('renderer functional tests', function()\n00150|   config.debug.show_ids = true\n00151| \n00152|   before_each(function()\n00153|     helpers.replay_setup()\n00154|   end)\n00155| \n00156|   after_each(function()\n00157|     if state.windows then\n00158|       ui.close_windows(state.windows)\n00159|     end\n00160|   end)\n00161| \n00162|   local json_files = vim.fn.glob('tests/data/*.json', false, true)\n00163| \n00164|   -- Don't do the full session test on these files, usually\n00165|   -- because they involve permission prompts\n00166|   local skip_full_session = {\n00167|     'permission-prompt',\n00168|     'permission-ask-new',\n00169|     'question-ask',\n00170|     'shifting-and-multiple-perms',\n00171|     'message-removal',\n00172|   }\n00173| \n00174|   for _, filepath in ipairs(json_files) do\n00175|     local name = vim.fn.fnamemodify(filepath, ':t:r')\n00176| \n00177|     if not name:match('%.expected$') then\n00178|       local expected_path = 'tests/data/' .. name .. '.expected.json'\n00179| \n00180|       if vim.fn.filereadable(expected_path) == 1 then\n00181|         for i = 1, 2 do\n00182|           config.ui.output.rendering.event_collapsing = i == 1 and true or false\n00183|           it(\n00184|             'replays '\n00185|               .. name\n00186|               .. ' correctly (event-by-event, '\n00187|               .. (config.ui.output.rendering.event_collapsing and 'collapsing' or 'no collapsing')\n00188|               .. ')',\n00189|             function()\n00190|               local events = helpers.load_test_data(filepath)\n00191|               state.active_session = helpers.get_session_from_events(events)\n00192|               local expected = helpers.load_test_data(expected_path)\n00193| \n00194|               helpers.replay_events(events)\n00195|               vim.wait(1000, function()\n00196|                 return vim.tbl_isempty(state.event_manager.throttling_emitter.queue)\n00197|               end)\n00198| \n00199|               local actual = helpers.capture_output(state.windows and state.windows.output_buf, output_window.namespace)\n00200|               assert_output_matches(expected, actual, name)\n00201|             end\n00202|           )\n00203|         end\n00204| \n00205|         if not vim.tbl_contains(skip_full_session, name) then\n00206|           it('replays ' .. name .. ' correctly (session)', function()\n00207|             local renderer = require('opencode.ui.renderer')\n00208|             local events = helpers.load_test_data(filepath)\n00209|             state.active_session = helpers.get_session_from_events(events, true)\n00210|             local expected = helpers.load_test_data(expected_path)\n00211| \n00212|             local session_data = helpers.load_session_from_events(events)\n00213|             renderer._render_full_session_data(session_data)\n00214| \n00215|             local actual = helpers.capture_output(state.windows and state.windows.output_buf, output_window.namespace)\n00216|             assert_output_matches(expected, actual, name)\n00217|           end)\n00218|         end\n00219|       end\n00220|     end\n00221|   end\n00222| end)\n00223| \n\n(End of file - total 223 lines)\n</file>",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "messageID": "msg_bfab6dbf3001ZOVHTFKR1CMUE5",
        "id": "prt_bfab6dbf80012C7P5ugGXl7Kbv",
        "synthetic": true
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "mime": "text/plain",
        "type": "file",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "id": "prt_bfab6dbf9001Kebk9O9AoUc4yI",
        "messageID": "msg_bfab6dbf3001ZOVHTFKR1CMUE5",
        "filename": "tests/replay/renderer_spec.lua",
        "url": "file:///home/francis/Projects/_nvim/opencode.nvim/tests/replay/renderer_spec.lua"
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "type": "text",
        "text": "can you use the question tool and ask me a couple of questions",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "messageID": "msg_bfab6dbf3001ZOVHTFKR1CMUE5",
        "id": "prt_bfab6dbf4001xrYv3BzlgWGgkv"
      }
    }
  },
  {
    "type": "session.updated",
    "properties": {
      "info": {
        "slug": "happy-harbor",
        "time": { "created": 1769437845874, "updated": 1769437846547 },
        "projectID": "29d43526f88157cd4edd071b899dd01f240b771b",
        "id": "ses_40549268dffehKpDd14uHIMQaT",
        "version": "1.1.31",
        "title": "New session - 2026-01-26T14:30:45.874Z",
        "directory": "/home/francis/Projects/_nvim/opencode.nvim"
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.updated",
    "properties": {
      "info": {
        "id": "msg_bfab6dc80001FueCN7E2691J2R",
        "modelID": "gpt-4.1",
        "providerID": "github-copilot",
        "cost": 0,
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "mode": "build",
        "time": { "created": 1769437846657 },
        "role": "assistant",
        "path": {
          "cwd": "/home/francis/Projects/_nvim/opencode.nvim",
          "root": "/home/francis/Projects/_nvim/opencode.nvim"
        },
        "agent": "build",
        "tokens": { "reasoning": 0, "input": 0, "output": 0, "cache": { "write": 0, "read": 0 } },
        "parentID": "msg_bfab6dbf3001ZOVHTFKR1CMUE5"
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.updated",
    "properties": {
      "info": {
        "id": "msg_bfab6dbf3001ZOVHTFKR1CMUE5",
        "time": { "created": 1769437846515 },
        "role": "user",
        "agent": "build",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "summary": { "diffs": [] },
        "model": { "providerID": "github-copilot", "modelID": "gpt-4.1" }
      }
    }
  },
  {
    "type": "session.updated",
    "properties": {
      "info": {
        "id": "ses_40549268dffehKpDd14uHIMQaT",
        "slug": "happy-harbor",
        "directory": "/home/francis/Projects/_nvim/opencode.nvim",
        "projectID": "29d43526f88157cd4edd071b899dd01f240b771b",
        "title": "New session - 2026-01-26T14:30:45.874Z",
        "version": "1.1.31",
        "summary": { "additions": 0, "deletions": 0, "files": 0 },
        "time": { "created": 1769437845874, "updated": 1769437846728 }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "type": "step-start",
        "snapshot": "be64b6205f0da4c9240df2476dc35495429161b5",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "messageID": "msg_bfab6dc80001FueCN7E2691J2R",
        "id": "prt_bfab6e0c10013qo2ZThCt7FqLA"
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "id": "prt_bfab6e0c4001ou3kcu0UICsKQq",
        "tool": "question",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "callID": "call_wHoqSXKi7juWQVtpwv4tMMTj",
        "messageID": "msg_bfab6dc80001FueCN7E2691J2R",
        "type": "tool",
        "state": { "raw": "", "input": {}, "status": "pending" }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "question.asked",
    "properties": {
      "questions": [
        {
          "question": "Which Lua testing framework do you use or prefer for your Neovim Lua plugins?",
          "header": "Testing Framework?",
          "options": [
            { "label": "busted", "description": "Busted is the most common Lua testing framework." },
            { "label": "plenary.nvim", "description": "Plenary.nvim provides unit test utilities for Neovim plugins." },
            { "label": "other", "description": "Other or custom test framework" }
          ]
        },
        {
          "question": "How do you usually run your tests in this codebase?",
          "header": "Run Tests Approach",
          "options": [
            { "label": "run_tests.sh (Recommended)", "description": "Use run_tests.sh script provided in repo root." },
            {
              "label": "Direct test runner",
              "description": "Use individual test commands (e.g., invoke Busted/Plenary directly)."
            },
            { "label": "Other", "description": "Other custom scripts or workflow" }
          ]
        }
      ],
      "id": "que_bfab6ef4f0010bzEmrR38ndiIA",
      "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
      "tool": { "messageID": "msg_bfab6dc80001FueCN7E2691J2R", "callID": "call_wHoqSXKi7juWQVtpwv4tMMTj" }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "id": "prt_bfab6e0c4001ou3kcu0UICsKQq",
        "tool": "question",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "callID": "call_wHoqSXKi7juWQVtpwv4tMMTj",
        "messageID": "msg_bfab6dc80001FueCN7E2691J2R",
        "type": "tool",
        "state": {
          "input": {
            "questions": [
              {
                "question": "Which Lua testing framework do you use or prefer for your Neovim Lua plugins?",
                "header": "Testing Framework?",
                "options": [
                  { "label": "busted", "description": "Busted is the most common Lua testing framework." },
                  {
                    "label": "plenary.nvim",
                    "description": "Plenary.nvim provides unit test utilities for Neovim plugins."
                  },
                  { "label": "other", "description": "Other or custom test framework" }
                ]
              },
              {
                "question": "How do you usually run your tests in this codebase?",
                "header": "Run Tests Approach",
                "options": [
                  {
                    "label": "run_tests.sh (Recommended)",
                    "description": "Use run_tests.sh script provided in repo root."
                  },
                  {
                    "label": "Direct test runner",
                    "description": "Use individual test commands (e.g., invoke Busted/Plenary directly)."
                  },
                  { "label": "Other", "description": "Other custom scripts or workflow" }
                ]
              }
            ]
          },
          "time": { "start": 1769437851471 },
          "status": "running"
        }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.updated",
    "properties": {
      "info": {
        "id": "msg_bfab6dbf3001ZOVHTFKR1CMUE5",
        "time": { "created": 1769437846515 },
        "role": "user",
        "agent": "build",
        "sessionID": "ses_40549268dffehKpDd14uHIMQaT",
        "summary": { "title": "Ask me two questions", "diffs": [] },
        "model": { "providerID": "github-copilot", "modelID": "gpt-4.1" }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "session.updated",
    "properties": {
      "info": {
        "id": "ses_40549268dffehKpDd14uHIMQaT",
        "slug": "happy-harbor",
        "directory": "/home/francis/Projects/_nvim/opencode.nvim",
        "projectID": "29d43526f88157cd4edd071b899dd01f240b771b",
        "title": "Ask questions about renderer_spec.lua",
        "version": "1.1.31",
        "summary": { "additions": 0, "deletions": 0, "files": 0 },
        "time": { "created": 1769437845874, "updated": 1769437846728 }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] }
]
