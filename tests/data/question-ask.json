[
  {
    "type": "session.updated",
    "properties": {
      "info": {
        "directory": "/home/francis/Projects/_nvim/opencode.nvim",
        "version": "1.1.31",
        "slug": "calm-lagoon",
        "id": "ses_4055f967bffeIHf3DnP0xntmxD",
        "title": "New session - 2026-01-26T14:06:15.428Z",
        "projectID": "29d43526f88157cd4edd071b899dd01f240b771b",
        "time": { "created": 1769436375428, "updated": 1769436375428 }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.updated",
    "properties": {
      "info": {
        "time": { "created": 1769436379298 },
        "id": "msg_bfaa078a2001RUYhlKZhSlyWeF",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "role": "user",
        "model": { "modelID": "gpt-4.1", "providerID": "github-copilot" },
        "agent": "build"
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "synthetic": true,
        "messageID": "msg_bfaa078a2001RUYhlKZhSlyWeF",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "text": "Called the Read tool with the following input: {\"filePath\":\"/home/francis/Projects/_nvim/opencode.nvim/lua/opencode/ui/renderer.lua\"}",
        "type": "text",
        "id": "prt_bfaa078a5001Pni4eaodfXL6o6"
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "synthetic": true,
        "messageID": "msg_bfaa078a2001RUYhlKZhSlyWeF",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "text": "<file>\n00001| local state = require('opencode.state')\n00002| local config = require('opencode.config')\n00003| local formatter = require('opencode.ui.formatter')\n00004| local output_window = require('opencode.ui.output_window')\n00005| local permission_window = require('opencode.ui.permission_window')\n00006| local Promise = require('opencode.promise')\n00007| local RenderState = require('opencode.ui.render_state')\n00008| \n00009| local M = {\n00010|   _prev_line_count = 0,\n00011|   _render_state = RenderState.new(),\n00012|   _last_part_formatted = {\n00013|     part_id = nil,\n00014|     formatted_data = nil --[[@as Output|nil]],\n00015|   },\n00016| }\n00017| \n00018| local trigger_on_data_rendered = require('opencode.util').debounce(function()\n00019|   local cb_type = type(config.ui.output.rendering.on_data_rendered)\n00020| \n00021|   if cb_type == 'boolean' then\n00022|     return\n00023|   end\n00024| \n00025|   if not state.windows or not state.windows.output_buf or not state.windows.output_win then\n00026|     return\n00027|   end\n00028| \n00029|   if cb_type == 'function' then\n00030|     pcall(config.ui.output.rendering.on_data_rendered, state.windows.output_buf, state.windows.output_win)\n00031|   elseif vim.fn.exists(':RenderMarkdown') > 0 then\n00032|     vim.cmd(':RenderMarkdown')\n00033|   elseif vim.fn.exists(':Markview') > 0 then\n00034|     vim.cmd(':Markview render ' .. state.windows.output_buf)\n00035|   end\n00036| end, config.ui.output.rendering.markdown_debounce_ms or 250)\n00037| \n00038| ---Reset renderer state\n00039| function M.reset()\n00040|   M._prev_line_count = 0\n00041|   M._render_state:reset()\n00042|   M._last_part_formatted = { part_id = nil, formatted_data = nil }\n00043| \n00044|   output_window.clear()\n00045| \n00046|   state.messages = {}\n00047|   state.last_user_message = nil\n00048|   state.tokens_count = 0\n00049| \n00050|   local permissions = state.pending_permissions or {}\n00051|   if #permissions and state.api_client then\n00052|     for _, permission in ipairs(permissions) do\n00053|       require('opencode.api').permission_deny(permission)\n00054|     end\n00055|   end\n00056|   permission_window.clear_all()\n00057|   state.pending_permissions = {}\n00058| \n00059|   trigger_on_data_rendered()\n00060| end\n00061| \n00062| ---Set up event subscriptions\n00063| ---@param subscribe? boolean false to unsubscribe\n00064| function M.setup_subscriptions(subscribe)\n00065|   subscribe = subscribe == nil and true or subscribe\n00066| \n00067|   if subscribe then\n00068|     state.subscribe('is_opencode_focused', M.on_focus_changed)\n00069|     state.subscribe('active_session', M.on_session_changed)\n00070|   else\n00071|     state.unsubscribe('is_opencode_focused', M.on_focus_changed)\n00072|     state.unsubscribe('active_session', M.on_session_changed)\n00073|   end\n00074| \n00075|   if not state.event_manager then\n00076|     return\n00077|   end\n00078| \n00079|   local event_subscriptions = {\n00080|     { 'session.updated', M.on_session_updated },\n00081|     { 'session.compacted', M.on_session_compacted },\n00082|     { 'session.error', M.on_session_error },\n00083|     { 'message.updated', M.on_message_updated },\n00084|     { 'message.removed', M.on_message_removed },\n00085|     { 'message.part.updated', M.on_part_updated },\n00086|     { 'message.part.removed', M.on_part_removed },\n00087|     { 'permission.updated', M.on_permission_updated },\n00088|     { 'permission.asked', M.on_permission_updated },\n00089|     { 'permission.replied', M.on_permission_replied },\n00090|     { 'question.asked', M.on_question_asked },\n00091|     { 'question.replied', M.clear_question_display },\n00092|     { 'question.rejected', M.clear_question_display },\n00093|     { 'file.edited', M.on_file_edited },\n00094|     { 'custom.restore_point.created', M.on_restore_points },\n00095|     { 'custom.emit_events.finished', M.on_emit_events_finished },\n00096|   }\n00097| \n00098|   for _, sub in ipairs(event_subscriptions) do\n00099|     if subscribe then\n00100|       state.event_manager:subscribe(sub[1], sub[2])\n00101|     else\n00102|       state.event_manager:unsubscribe(sub[1], sub[2])\n00103|     end\n00104|   end\n00105| end\n00106| \n00107| ---Clean up and teardown renderer. Unsubscribes from all events\n00108| function M.teardown()\n00109|   M.setup_subscriptions(false)\n00110|   M.reset()\n00111| end\n00112| \n00113| ---Fetch full session messages from server\n00114| ---@return Promise<OpencodeMessage[]> Promise resolving to list of OpencodeMessage\n00115| local function fetch_session()\n00116|   local session = state.active_session\n00117|   if not session or not session or session == '' then\n00118|     return Promise.new():resolve(nil)\n00119|   end\n00120| \n00121|   state.last_user_message = nil\n00122|   return require('opencode.session').get_messages(session)\n00123| end\n00124| \n00125| ---Request all of the session data from the opencode server and render it\n00126| ---@return Promise<OpencodeMessage[]>\n00127| function M.render_full_session()\n00128|   if not output_window.mounted() or not state.api_client then\n00129|     return Promise.new():resolve(nil)\n00130|   end\n00131| \n00132|   return fetch_session():and_then(M._render_full_session_data)\n00133| end\n00134| \n00135| function M._render_full_session_data(session_data)\n00136|   M.reset()\n00137| \n00138|   if not state.active_session or not state.messages then\n00139|     return\n00140|   end\n00141| \n00142|   local revert_index = nil\n00143| \n00144|   -- if we're loading a session and there's no currently selected model, set it\n00145|   -- from the messages\n00146|   local set_mode_from_messages = not state.current_model\n00147| \n00148|   for i, msg in ipairs(session_data) do\n00149|     if state.active_session.revert and state.active_session.revert.messageID == msg.info.id then\n00150|       revert_index = i\n00151|     end\n00152| \n00153|     M.on_message_updated({ info = msg.info }, revert_index)\n00154| \n00155|     for _, part in ipairs(msg.parts or {}) do\n00156|       M.on_part_updated({ part = part }, revert_index)\n00157|     end\n00158|   end\n00159| \n00160|   if revert_index then\n00161|     M._write_formatted_data(formatter._format_revert_message(state.messages, revert_index))\n00162|   end\n00163| \n00164|   if set_mode_from_messages then\n00165|     M._set_model_and_mode_from_messages()\n00166|   end\n00167|   M.scroll_to_bottom()\n00168| \n00169|   if config.hooks and config.hooks.on_session_loaded then\n00170|     pcall(config.hooks.on_session_loaded, state.active_session)\n00171|   end\n00172| end\n00173| \n00174| ---Append permissions display as a fake part at the end\n00175| function M.render_permissions_display()\n00176|   local fake_message = {\n00177|     info = {\n00178|       id = 'permission-display-message',\n00179|       sessionID = state.active_session and state.active_session.id or '',\n00180|       role = 'system',\n00181|     },\n00182|     parts = {},\n00183|   }\n00184|   M.on_message_updated(fake_message)\n00185| \n00186|   local fake_part = {\n00187|     id = 'permission-display-part',\n00188|     messageID = 'permission-display-message',\n00189|     sessionID = state.active_session and state.active_session.id or '',\n00190|     type = 'permissions-display',\n00191|   }\n00192| \n00193|   local permissions = permission_window.get_all_permissions()\n00194|   if #permissions > 0 then\n00195|     M.on_part_updated({ part = fake_part })\n00196|   end\n00197| end\n00198| \n00199| function M.clear_question_display()\n00200|   local question_window = require('opencode.ui.question_window')\n00201|   question_window.clear_question()\n00202|   M._remove_part_from_buffer('question-display-part')\n00203|   M._remove_message_from_buffer('question-display-message')\n00204| end\n00205| \n00206| ---Render question display as a fake part\n00207| function M.render_question_display()\n00208|   local question_window = require('opencode.ui.question_window')\n00209| \n00210|   local current_question = question_window._current_question\n00211| \n00212|   if not question_window.has_question() or not current_question or not current_question.id then\n00213|     M._remove_part_from_buffer('question-display-part')\n00214|     M._remove_message_from_buffer('question-display-message')\n00215|     return\n00216|   end\n00217| \n00218|   local message_id = 'question-display-message'\n00219|   local part_id = 'question-display-part'\n00220| \n00221|   local fake_message = {\n00222|     info = {\n00223|       id = message_id,\n00224|       sessionID = state.active_session and state.active_session.id or '',\n00225|       role = 'system',\n00226|     },\n00227|     parts = {},\n00228|   }\n00229|   M.on_message_updated(fake_message)\n00230| \n00231|   local fake_part = {\n00232|     id = part_id,\n00233|     messageID = message_id,\n00234|     sessionID = state.active_session and state.active_session.id or '',\n00235|     type = 'questions-display',\n00236|   }\n00237| \n00238|   M.on_part_updated({ part = fake_part })\n00239|   M._redraw()\n00240|   M.scroll_to_bottom(true)\n00241| end\n00242| \n00243| function M._redraw()\n00244|   if state.windows and state.windows.output_win and vim.api.nvim_win_is_valid(state.windows.output_win) then\n00245|     vim.api.nvim_win_call(state.windows.output_win, function()\n00246|       vim.cmd('redraw')\n00247|     end)\n00248|   end\n00249| end\n00250| \n00251| ---Render lines as the entire output buffer\n00252| ---@param lines any\n00253| function M.render_lines(lines)\n00254|   local output = require('opencode.ui.output'):new()\n00255|   output.lines = lines\n00256|   M.render_output(output)\n00257| end\n00258| \n00259| ---Sets the entire output buffer based on output_data\n00260| ---@param output_data Output Output object from formatter\n00261| function M.render_output(output_data)\n00262|   if not output_window.mounted() then\n00263|     return\n00264|   end\n00265| \n00266|   local lines = output_data.lines or {}\n00267| \n00268|   output_window.set_lines(lines)\n00269|   output_window.clear_extmarks()\n00270|   output_window.set_extmarks(output_data.extmarks)\n00271|   M.scroll_to_bottom()\n00272| end\n00273| \n00274| ---Called when EventManager has finished emitting a batch of events\n00275| function M.on_emit_events_finished()\n00276|   M.scroll_to_bottom()\n00277| end\n00278| \n00279| ---Find the most recently used model from the messages\n00280| function M._set_model_and_mode_from_messages()\n00281|   if not state.messages then\n00282|     return\n00283|   end\n00284| \n00285|   for i = #state.messages, 1, -1 do\n00286|     local message = state.messages[i]\n00287| \n00288|     if message and message.info then\n00289|       if message.info.modelID and message.info.providerID then\n00290|         state.current_model = message.info.providerID .. '/' .. message.info.modelID\n00291|         if message.info.mode then\n00292|           state.current_mode = message.info.mode\n00293|         end\n00294|         return\n00295|       end\n00296|     end\n00297|   end\n00298| \n00299|   -- we didn't find a model from any messages, set it to the default\n00300|   require('opencode.core').initialize_current_model()\n00301| end\n00302| \n00303| ---Auto-scroll to bottom if user was already at bottom\n00304| ---Respects cursor position if user has scrolled up\n00305| ---@param force? boolean If true, scroll regardless of current position\n00306| function M.scroll_to_bottom(force)\n00307|   if not state.windows or not state.windows.output_buf or not state.windows.output_win then\n00308|     return\n00309|   end\n00310| \n00311|   if not vim.api.nvim_win_is_valid(state.windows.output_win) then\n00312|     return\n00313|   end\n00314| \n00315|   local ok, line_count = pcall(vim.api.nvim_buf_line_count, state.windows.output_buf)\n00316|   if not ok or line_count == 0 then\n00317|     return\n00318|   end\n00319| \n00320|   local prev_line_count = M._prev_line_count or 0\n00321| \n00322|   ---@cast line_count integer\n00323|   M._prev_line_count = line_count\n00324| \n00325|   trigger_on_data_rendered()\n00326| \n00327|   -- Determine if we should scroll to bottom\n00328|   local should_scroll = force == true\n00329| \n00330|   if not should_scroll then\n00331|     -- Always scroll on initial render\n00332|     if prev_line_count == 0 then\n00333|       should_scroll = true\n00334|     -- Scroll if user is at bottom (respects manual scroll position)\n00335|     elseif output_window.viewport_at_bottom then\n00336|       should_scroll = true\n00337|     end\n00338|   end\n00339| \n00340|   if should_scroll then\n00341|     vim.api.nvim_win_set_cursor(state.windows.output_win, { line_count, 0 })\n00342|     -- Use zb to position the cursor line at the bottom of the visible window\n00343|     vim.api.nvim_win_call(state.windows.output_win, function()\n00344|       vim.cmd('normal! zb')\n00345|     end)\n00346|     output_window.viewport_at_bottom = true\n00347|   else\n00348|     -- User has scrolled up, don't scroll\n00349|     output_window.viewport_at_bottom = false\n00350|   end\n00351| end\n00352| \n00353| ---Write data to output_buf, including normal text and extmarks\n00354| ---@param formatted_data Output Formatted data as Output object\n00355| ---@param part_id? string Optional part ID to store actions\n00356| ---@param start_line? integer Optional line to insert at (shifts content down). If nil, appends to end of buffer.\n00357| ---@return {line_start: integer, line_end: integer}? Range where data was written\n00358| function M._write_formatted_data(formatted_data, part_id, start_line)\n00359|   if not state.windows or not state.windows.output_buf then\n00360|     return\n00361|   end\n00362| \n00363|   local buf = state.windows.output_buf\n00364|   local is_insertion = start_line ~= nil\n00365|   local target_line = start_line or output_window.get_buf_line_count()\n00366|   local new_lines = formatted_data.lines\n00367|   local extmarks = formatted_data.extmarks\n00368| \n00369|   if #new_lines == 0 or not buf then\n00370|     return nil\n00371|   end\n00372| \n00373|   if is_insertion then\n00374|     output_window.set_lines(new_lines, target_line, target_line)\n00375|   else\n00376|     local extra_newline = vim.tbl_extend('keep', {}, new_lines)\n00377|     table.insert(extra_newline, '')\n00378|     target_line = target_line - 1\n00379|     output_window.set_lines(extra_newline, target_line)\n00380|   end\n00381| \n00382|   -- update actions and extmarks after the insertion because that may\n00383|   -- adjust target_line (e.g. when we we're replacing the double newline at\n00384|   -- the end)\n00385| \n00386|   if part_id and formatted_data.actions then\n00387|     M._render_state:add_actions(part_id, formatted_data.actions, target_line)\n00388|   end\n00389| \n00390|   output_window.set_extmarks(extmarks, target_line)\n00391| \n00392|   return {\n00393|     line_start = target_line,\n00394|     line_end = target_line + #new_lines - 1,\n00395|   }\n00396| end\n00397| \n00398| ---Insert new part, either at end of buffer or in the middle for out-of-order parts\n00399| ---@param part_id string Part ID\n00400| ---@param formatted_data Output Formatted data as Output object\n00401| ---@return boolean Success status\n00402| function M._insert_part_to_buffer(part_id, formatted_data)\n00403|   local cached = M._render_state:get_part(part_id)\n00404|   if not cached then\n00405|     return false\n00406|   end\n00407| \n00408|   if #formatted_data.lines == 0 then\n00409|     return true\n00410|   end\n00411| \n00412|   local is_current_message = state.current_message\n00413|     and state.current_message.info\n00414|     and state.current_message.info.id == cached.message_id\n00415| \n00416|   if is_current_message then\n00417|     -- NOTE: we're inserting a part for the current message, just add it to the end\n00418| \n00419|     local range = M._write_formatted_data(formatted_data, part_id)\n00420|     if not range then\n00421|       return false\n00422|     end\n00423| \n00424|     M._render_state:set_part(cached.part, range.line_start, range.line_end)\n00425| \n00426|     M._last_part_formatted = { part_id = part_id, formatted_data = formatted_data }\n00427| \n00428|     return true\n00429|   end\n00430| \n00431|   -- NOTE: We're inserting a part for the first time for a previous message. We need to find\n00432|   -- the insertion line (after the last part of this message or after the message header if\n00433|   -- no parts).\n00434|   local insertion_line = M._get_insertion_point_for_part(part_id, cached.message_id)\n00435|   if not insertion_line then\n00436|     return false\n00437|   end\n00438| \n00439|   local range = M._write_formatted_data(formatted_data, part_id, insertion_line)\n00440|   if not range then\n00441|     return false\n00442|   end\n00443| \n00444|   local line_count = #formatted_data.lines\n00445|   M._render_state:shift_all(insertion_line, line_count)\n00446| \n00447|   M._render_state:set_part(cached.part, range.line_start, range.line_end)\n00448| \n00449|   return true\n00450| end\n00451| \n00452| ---Replace existing part in buffer\n00453| ---Adjusts line positions of subsequent parts if line count changes\n00454| ---@param part_id string Part ID\n00455| ---@param formatted_data Output Formatted data as Output object\n00456| ---@return boolean Success status\n00457| function M._replace_part_in_buffer(part_id, formatted_data)\n00458|   local cached = M._render_state:get_part(part_id)\n00459|   if not cached or not cached.line_start or not cached.line_end then\n00460|     return false\n00461|   end\n00462| \n00463|   local new_lines = formatted_data.lines\n00464|   local new_line_count = #new_lines\n00465| \n00466|   local old_formatted = M._last_part_formatted\n00467|   local can_optimize = old_formatted\n00468|     and old_formatted.part_id == part_id\n00469|     and old_formatted.formatted_data\n00470|     and old_formatted.formatted_data.lines\n00471| \n00472|   local lines_to_write = new_lines\n00473|   local write_start_line = cached.line_start\n00474| \n00475|   if can_optimize then\n00476|     -- NOTE: This is an optimization to only replace the lines that are different\n00477|     -- if we're replacing the most recently formatted part.\n00478| \n00479|     ---@cast old_formatted { formatted_data: { lines: string[] } }\n00480|     local old_lines = old_formatted.formatted_data.lines\n00481|     local first_diff_line = nil\n00482| \n00483|     -- Find the first line that's different\n00484|     for i = 1, math.min(#old_lines, new_line_count) do\n00485|       if old_lines[i] ~= new_lines[i] then\n00486|         first_diff_line = i\n00487|         break\n00488|       end\n00489|     end\n00490| \n00491|     if not first_diff_line and new_line_count > #old_lines then\n00492|       -- The old lines all matched but maybe there are more new lines\n00493|       first_diff_line = #old_lines + 1\n00494|     end\n00495| \n00496|     if first_diff_line then\n00497|       lines_to_write = vim.list_slice(new_lines, first_diff_line, new_line_count)\n00498|       write_start_line = cached.line_start + first_diff_line - 1\n00499|     elseif new_line_count == #old_lines then\n00500|       -- Nothing was different, so we're done\n00501|       M._last_part_formatted = { part_id = part_id, formatted_data = formatted_data }\n00502|       return true\n00503|     end\n00504|   end\n00505| \n00506|   M._render_state:clear_actions(part_id)\n00507| \n00508|   output_window.clear_extmarks(cached.line_start - 1, cached.line_end + 1)\n00509|   output_window.set_lines(lines_to_write, write_start_line, cached.line_end + 1)\n00510| \n00511|   local new_line_end = cached.line_start + new_line_count - 1\n00512| \n00513|   output_window.set_extmarks(formatted_data.extmarks, cached.line_start)\n00514| \n00515|   if formatted_data.actions then\n00516|     M._render_state:add_actions(part_id, formatted_data.actions, cached.line_start + 1)\n00517|   end\n00518| \n00519|   M._render_state:update_part_lines(part_id, cached.line_start, new_line_end)\n00520| \n00521|   M._last_part_formatted = { part_id = part_id, formatted_data = formatted_data }\n00522| \n00523|   return true\n00524| end\n00525| \n00526| ---Remove part from buffer and adjust subsequent line positions\n00527| ---@param part_id string Part ID\n00528| function M._remove_part_from_buffer(part_id)\n00529|   local cached = M._render_state:get_part(part_id)\n00530|   if not cached or not cached.line_start or not cached.line_end then\n00531|     return\n00532|   end\n00533| \n00534|   if not state.windows or not state.windows.output_buf then\n00535|     return\n00536|   end\n00537| \n00538|   output_window.clear_extmarks(cached.line_start - 1, cached.line_end)\n00539|   output_window.set_lines({}, cached.line_start - 1, cached.line_end)\n00540| \n00541|   M._render_state:remove_part(part_id)\n00542| end\n00543| \n00544| ---Remove message header from buffer and adjust subsequent line positions\n00545| ---@param message_id string Message ID\n00546| function M._remove_message_from_buffer(message_id)\n00547|   local cached = M._render_state:get_message(message_id)\n00548|   if not cached or not cached.line_start or not cached.line_end then\n00549|     return\n00550|   end\n00551| \n00552|   if not state.windows or not state.windows.output_buf then\n00553|     return\n00554|   end\n00555| \n00556|   output_window.clear_extmarks(cached.line_start - 1, cached.line_end)\n00557|   output_window.set_lines({}, cached.line_start - 1, cached.line_end)\n00558| \n00559|   M._render_state:remove_message(message_id)\n00560| end\n00561| \n00562| ---Adds a message (most likely just a header) to the buffer\n00563| ---@param message OpencodeMessage Message to add\n00564| function M._add_message_to_buffer(message)\n00565|   local header_data = formatter.format_message_header(message)\n00566|   local range = M._write_formatted_data(header_data)\n00567| \n00568|   if range then\n00569|     M._render_state:set_message(message, range.line_start, range.line_end)\n00570|   end\n00571| end\n00572| \n00573| ---Replace existing message header in buffer\n00574| ---@param message_id string Message ID\n00575| ---@param formatted_data Output Formatted header as Output object\n00576| ---@return boolean Success status\n00577| function M._replace_message_in_buffer(message_id, formatted_data)\n00578|   local cached = M._render_state:get_message(message_id)\n00579|   if not cached or not cached.line_start or not cached.line_end then\n00580|     return false\n00581|   end\n00582| \n00583|   local new_lines = formatted_data.lines\n00584|   local new_line_count = #new_lines\n00585| \n00586|   output_window.clear_extmarks(cached.line_start, cached.line_end + 1)\n00587|   output_window.set_lines(new_lines, cached.line_start, cached.line_end + 1)\n00588|   output_window.set_extmarks(formatted_data.extmarks, cached.line_start)\n00589| \n00590|   local old_line_end = cached.line_end\n00591|   local new_line_end = cached.line_start + new_line_count - 1\n00592| \n00593|   M._render_state:set_message(cached.message, cached.line_start, new_line_end)\n00594| \n00595|   local delta = new_line_end - old_line_end\n00596|   if delta ~= 0 then\n00597|     M._render_state:shift_all(old_line_end + 1, delta)\n00598|   end\n00599| \n00600|   return true\n00601| end\n00602| \n00603| ---Event handler for message.updated events\n00604| ---Creates new message or updates existing message info\n00605| ---@param message {info: MessageInfo} Event properties\n00606| ---@param revert_index? integer Revert index in session, if applicable\n00607| function M.on_message_updated(message, revert_index)\n00608|   if not state.active_session or not state.messages then\n00609|     return\n00610|   end\n00611| \n00612|   local msg = message --[[@as OpencodeMessage]]\n00613|   if not msg or not msg.info or not msg.info.id or not msg.info.sessionID then\n00614|     return\n00615|   end\n00616| \n00617|   if state.active_session.id ~= msg.info.sessionID then\n00618|     ---@TODO This is probably a child session message, handle differently?\n00619|     -- vim.notify('Session id does not match, discarding message: ' .. vim.inspect(message), vim.log.levels.WARN)\n00620|     return\n00621|   end\n00622| \n00623|   local rendered_message = M._render_state:get_message(msg.info.id)\n00624|   local found_msg = rendered_message and rendered_message.message\n00625| \n00626|   if revert_index then\n00627|     if not found_msg then\n00628|       table.insert(state.messages, msg)\n00629|     end\n00630|     M._render_state:set_message(msg, 0, 0)\n00631|     return\n00632|   end\n00633| \n00634|   if found_msg then\n00635|     local error_changed = not vim.deep_equal(found_msg.info.error, msg.info.error)\n00636| \n00637|     found_msg.info = msg.info\n00638| \n00639|     --- NOTE: error handling is a bit messy because errors come in on messages\n00640|     --- but we want to display the error at the end. In this case, we an error\n00641|     --- was added to this message. We find the last part and re-render it to\n00642|     --- display the message. If there are no parts, we'll re-render the message\n00643| \n00644|     if error_changed and not revert_index then\n00645|       local last_part_id = M._get_last_part_for_message(found_msg)\n00646|       if last_part_id then\n00647|         M._rerender_part(last_part_id)\n00648|       else\n00649|         local header_data = formatter.format_message_header(found_msg)\n00650|         M._replace_message_in_buffer(msg.info.id, header_data)\n00651|       end\n00652|     end\n00653|   else\n00654|     table.insert(state.messages, msg)\n00655| \n00656|     M._add_message_to_buffer(msg)\n00657| \n00658|     state.current_message = msg\n00659|     if message.info.role == 'user' then\n00660|       state.last_user_message = msg\n00661|     end\n00662|   end\n00663| \n00664|   M._update_stats_from_message(msg)\n00665| end\n00666| \n00667| ---Event handler for message.part.updated events\n00668| ---Inserts new parts or replaces existing parts in buffer\n00669| ---@param properties {part: OpencodeMessagePart} Event properties\n00670| ---@param revert_index? integer Revert index in session, if applicable\n00671| function M.on_part_updated(properties, revert_index)\n00672|   if not properties or not properties.part or not state.active_session then\n00673|     return\n00674|   end\n00675| \n00676|   local part = properties.part\n00677|   if not part.id or not part.messageID or not part.sessionID then\n00678|     return\n00679|   end\n00680| \n00681|   if state.active_session.id ~= part.sessionID then\n00682|     ---@TODO This is probably a child session part, handle differently?\n00683|     -- vim.notify('Session id does not match, discarding part: ' .. vim.inspect(part), vim.log.levels.WARN)\n00684|     return\n00685|   end\n00686| \n00687|   local rendered_message = M._render_state:get_message(part.messageID)\n00688|   if not rendered_message or not rendered_message.message then\n00689|     vim.notify('Could not find message for part: ' .. vim.inspect(part), vim.log.levels.WARN)\n00690|     return\n00691|   end\n00692| \n00693|   local message = rendered_message.message\n00694| \n00695|   message.parts = message.parts or {}\n00696| \n00697|   local part_data = M._render_state:get_part(part.id)\n00698|   local is_new_part = not part_data\n00699| \n00700|   local prev_last_part_id = M._get_last_part_for_message(message)\n00701|   local is_last_part = is_new_part or (prev_last_part_id == part.id)\n00702| \n00703|   if is_new_part then\n00704|     table.insert(message.parts, part)\n00705|   else\n00706|     for i = #message.parts, 1, -1 do\n00707|       if message.parts[i].id == part.id then\n00708|         message.parts[i] = part\n00709|         break\n00710|       end\n00711|     end\n00712|   end\n00713| \n00714|   if part.type == 'step-start' or part.type == 'step-finish' then\n00715|     return\n00716|   end\n00717| \n00718|   if is_new_part then\n00719|     M._render_state:set_part(part)\n00720|   else\n00721|     local rendered_part = M._render_state:update_part_data(part)\n00722|     -- NOTE: This isn't the first time we've seen the part but we haven't rendered it previously\n00723|     -- so try and render it this time by setting is_new_part = true (otherwise we'd call\n00724|     -- _replace_message_in_buffer and it wouldn't do anything because the part hasn't been rendered)\n00725|     if not rendered_part or (not rendered_part.line_start and not rendered_part.line_end) then\n00726|       is_new_part = true\n00727|     end\n00728|   end\n00729| \n00730|   local formatted = formatter.format_part(part, message, is_last_part)\n00731| \n00732|   if revert_index and is_new_part then\n00733|     return\n00734|   end\n00735| \n00736|   if is_new_part then\n00737|     M._insert_part_to_buffer(part.id, formatted)\n00738| \n00739|     if message.info.error then\n00740|       --- NOTE: More error display code. As mentioned above, errors come in on messages\n00741|       --- but we want to display them after parts so we tack the error onto the last\n00742|       --- part. When a part is added and there's an error, we need to rerender\n00743|       --- previous last part so it doesn't also display the message. If there was no previous\n00744|       --- part, then we need to rerender the header so it doesn't display the error\n00745| \n00746|       if not prev_last_part_id then\n00747|         -- no previous part, we're the first part, re-render the message header\n00748|         -- so it doesn't also display the error\n00749|         local header_data = formatter.format_message_header(message)\n00750|         M._replace_message_in_buffer(part.messageID, header_data)\n00751|       elseif prev_last_part_id ~= part.id then\n00752|         M._rerender_part(prev_last_part_id)\n00753|       end\n00754|     end\n00755|   else\n00756|     M._replace_part_in_buffer(part.id, formatted)\n00757|   end\n00758| \n00759|   if (part.type == 'file' or part.type == 'agent') and part.source then\n00760|     -- we have a mention, we need to rerender the early part to highlight\n00761|     -- the mention.\n00762|     local text_part_id = M._find_text_part_for_message(message)\n00763|     if text_part_id then\n00764|       M._rerender_part(text_part_id)\n00765|     end\n00766|   end\n00767| end\n00768| \n00769| ---Event handler for message.part.removed events\n00770| ---@param properties {sessionID: string, messageID: string, partID: string} Event properties\n00771| function M.on_part_removed(properties)\n00772|   if not properties then\n00773|     return\n00774|   end\n00775| \n00776|   local part_id = properties.partID\n00777|   if not part_id then\n00778|     return\n00779|   end\n00780| \n00781|   local cached = M._render_state:get_part(part_id)\n00782|   if cached and cached.message_id then\n00783|     local rendered_message = M._render_state:get_message(cached.message_id)\n00784|     if rendered_message and rendered_message.message then\n00785|       local message = rendered_message.message\n00786|       if message.parts then\n00787|         for i, part in ipairs(message.parts) do\n00788|           if part.id == part_id then\n00789|             table.remove(message.parts, i)\n00790|             break\n00791|           end\n00792|         end\n00793|       end\n00794|     end\n00795|   end\n00796| \n00797|   M._remove_part_from_buffer(part_id)\n00798| end\n00799| \n00800| ---Event handler for message.removed events\n00801| ---Removes message and all its parts from buffer\n00802| ---@param properties {sessionID: string, messageID: string} Event properties\n00803| function M.on_message_removed(properties)\n00804|   if not properties or not state.messages then\n00805|     return\n00806|   end\n00807| \n00808|   local message_id = properties.messageID\n00809|   if not message_id then\n00810|     return\n00811|   end\n00812| \n00813|   local rendered_message = M._render_state:get_message(message_id)\n00814|   if not rendered_message or not rendered_message.message then\n00815|     return\n00816|   end\n00817| \n00818|   local message = rendered_message.message\n00819|   for _, part in ipairs(message.parts or {}) do\n00820|     if part.id then\n00821|       M._remove_part_from_buffer(part.id)\n00822|     end\n00823|   end\n00824| \n00825|   M._remove_message_from_buffer(message_id)\n00826| \n00827|   for i, msg in ipairs(state.messages or {}) do\n00828|     if msg.info.id == message_id then\n00829|       table.remove(state.messages, i)\n00830|       break\n00831|     end\n00832|   end\n00833| end\n00834| \n00835| ---Event handler for session.compacted events\n00836| ---@param properties {sessionID: string} Event properties\n00837| function M.on_session_compacted(properties)\n00838|   vim.notify('Session has been compacted')\n00839| end\n00840| \n00841| ---Event handler for session.updated events\n00842| ---@param properties {info: Session}\n00843| function M.on_session_updated(properties)\n00844|   if not properties or not properties.info or not state.active_session then\n00845|     return\n00846|   end\n00847|   if not vim.deep_equal(state.active_session.revert, properties.info.revert) then\n00848|     state.active_session.revert = properties.info.revert\n00849|     M._render_full_session_data(state.messages)\n00850|   end\n00851| end\n00852| \n00853| ---Event handler for session.error events\n00854| ---@param properties {sessionID: string, error: table} Event properties\n00855| function M.on_session_error(properties)\n00856|   if not properties or not properties.error then\n00857|     return\n00858|   end\n00859| \n00860|   -- NOTE: we're handling message errors so session errors seem duplicative\n00861|   if config.debug.enabled then\n00862|     vim.notify('Session error: ' .. vim.inspect(properties.error))\n00863|   end\n00864| end\n00865| \n00866| ---Event handler for permission.updated events\n00867| ---Re-renders part that requires permission and adds to permission window\n00868| ---@param permission OpencodePermission Event properties\n00869| function M.on_permission_updated(permission)\n00870|   local tool = permission.tool\n00871| \n00872|   ---@TODO this is for backward compatibility, remove later\n00873|   local callID = tool and tool.callID or permission.callID\n00874|   local messageID = tool and tool.messageID or permission.messageID\n00875| \n00876|   if not permission or not messageID or not callID then\n00877|     return\n00878|   end\n00879| \n00880|   -- Add permission to pending queue\n00881|   if not state.pending_permissions then\n00882|     state.pending_permissions = {}\n00883|   end\n00884| \n00885|   -- Check if permission already exists in queue\n00886|   local existing_index = nil\n00887|   for i, existing in ipairs(state.pending_permissions) do\n00888|     if existing.id == permission.id then\n00889|       existing_index = i\n00890|       break\n00891|     end\n00892|   end\n00893| \n00894|   local permissions = vim.deepcopy(state.pending_permissions)\n00895|   if existing_index then\n00896|     permissions[existing_index] = permission\n00897|   else\n00898|     table.insert(permissions, permission)\n00899|   end\n00900|   state.pending_permissions = permissions\n00901| \n00902|   permission_window.add_permission(permission)\n00903| \n00904|   M.render_permissions_display()\n00905| \n00906|   M._rerender_part('permission-display-part')\n00907|   M.scroll_to_bottom()\n00908| end\n00909| \n00910| ---Event handler for permission.replied events\n00911| ---Re-renders part after permission is resolved and removes from window\n00912| ---@param properties {sessionID: string, permissionID?: string,requestID?: string, response: string}|{} Event properties\n00913| function M.on_permission_replied(properties)\n00914|   if not properties then\n00915|     return\n00916|   end\n00917| \n00918|   local permission_id = properties.permissionID or properties.requestID\n00919| \n00920|   if permission_id then\n00921|     permission_window.remove_permission(permission_id)\n00922|     state.pending_permissions = vim.deepcopy(permission_window.get_all_permissions())\n00923|     if #state.pending_permissions == 0 then\n00924|       M._remove_part_from_buffer('permission-display-part')\n00925|       M._remove_message_from_buffer('permission-display-message')\n00926|     end\n00927|     M._rerender_part('permission-display-part')\n00928|   end\n00929| end\n00930| \n00931| ---Event handler for question.asked events\n00932| ---Shows the question picker UI for the user to answer\n00933| ---@param properties OpencodeQuestionRequest Event properties\n00934| function M.on_question_asked(properties)\n00935|   if not properties or not properties.id or not properties.questions then\n00936|     return\n00937|   end\n00938| \n00939|   if not state.active_session or properties.sessionID ~= state.active_session.id then\n00940|     return\n00941|   end\n00942| \n00943|   local question_window = require('opencode.ui.question_window')\n00944|   question_window.show_question(properties)\n00945| end\n00946| \n00947| function M.on_file_edited(properties)\n00948|   vim.cmd('checktime')\n00949|   if config.hooks and config.hooks.on_file_edited then\n00950|     pcall(config.hooks.on_file_edited, properties.file)\n00951|   end\n00952| end\n00953| \n00954| ---@param properties RestorePointCreatedEvent\n00955| function M.on_restore_points(properties)\n00956|   state.append('restore_points', properties.restore_point)\n00957|   if not properties or not properties.restore_point or not properties.restore_point.from_snapshot_id then\n00958|     return\n00959|   end\n00960|   local part = M._render_state:get_part_by_snapshot_id(properties.restore_point.from_snapshot_id)\n00961|   if part then\n00962|     M.on_part_updated({ part = part })\n00963|   end\n00964| end\n00965| \n00966| ---Find part ID by call ID and message ID\n00967| ---Useful for finding a part for a permission\n00968| ---@param call_id string Call ID to search for\n00969| ---@param message_id string Message ID to check the parts of\n00970| ---@return string? part_id Part ID if found, nil otherwise\n00971| function M._find_part_by_call_id(call_id, message_id)\n00972|   return M._render_state:get_part_by_call_id(call_id, message_id)\n00973| end\n00974| \n00975| ---Find the text part in a message\n00976| ---@param message OpencodeMessage The message containing the parts\n00977| ---@return string? text_part_id The ID of the text part\n00978| function M._find_text_part_for_message(message)\n00979|   if not message or not message.parts then\n00980|     return nil\n00981|   end\n00982| \n00983|   for _, part in ipairs(message.parts) do\n00984|     if part.type == 'text' and not part.synthetic then\n00985|       return part.id\n00986|     end\n00987|   end\n00988| \n00989|   return nil\n00990| end\n00991| \n00992| ---Find the last part in a message\n00993| ---@param message OpencodeMessage The message containing the parts\n00994| ---@return string? last_part_id The ID of the last part\n00995| function M._get_last_part_for_message(message)\n00996|   if not message or not message.parts or #message.parts == 0 then\n00997|     return nil\n00998|   end\n00999| \n01000|   for i = #message.parts, 1, -1 do\n01001|     local part = message.parts[i]\n01002|     if part.type ~= 'step-start' and part.type ~= 'step-finish' and part.id then\n01003|       return part.id\n01004|     end\n01005|   end\n01006| \n01007|   return nil\n01008| end\n01009| \n01010| ---Get insertion point for an out-of-order part\n01011| ---@param part_id string The part ID to insert\n01012| ---@param message_id string The message ID the part belongs to\n01013| ---@return integer? insertion_line The line to insert at (1-indexed), or nil on error\n01014| function M._get_insertion_point_for_part(part_id, message_id)\n01015|   local rendered_message = M._render_state:get_message(message_id)\n01016|   if not rendered_message or not rendered_message.message then\n01017|     return nil\n01018|   end\n01019| \n01020|   local message = rendered_message.message\n01021| \n01022|   local insertion_line = rendered_message.line_end and (rendered_message.line_end + 1)\n01023|   if not insertion_line then\n01024|     return nil\n01025|   end\n01026| \n01027|   local current_part_index = nil\n01028|   if message.parts then\n01029|     for i, part in ipairs(message.parts) do\n01030|       if part.id == part_id then\n01031|         current_part_index = i\n01032|         break\n01033|       end\n01034|     end\n01035|   end\n01036| \n01037|   if not current_part_index then\n01038|     return insertion_line\n01039|   end\n01040| \n01041|   for i = current_part_index - 1, 1, -1 do\n01042|     local prev_part = message.parts[i]\n01043|     if prev_part and prev_part.id then\n01044|       local prev_rendered = M._render_state:get_part(prev_part.id)\n01045| \n01046|       if prev_rendered and prev_rendered.line_end then\n01047|         return prev_rendered.line_end + 1\n01048|       end\n01049|     end\n01050|   end\n01051| \n01052|   return insertion_line\n01053| end\n01054| \n01055| ---Re-render existing part with current state\n01056| ---Used for permission updates and other dynamic changes\n01057| ---@param part_id string Part ID to re-render\n01058| function M._rerender_part(part_id)\n01059|   local cached = M._render_state:get_part(part_id)\n01060|   if not cached or not cached.part then\n01061|     return\n01062|   end\n01063| \n01064|   local part = cached.part\n01065|   local rendered_message = M._render_state:get_message(cached.message_id)\n01066|   if not rendered_message or not rendered_message.message then\n01067|     return\n01068|   end\n01069| \n01070|   local message = rendered_message.message\n01071|   local last_part_id = M._get_last_part_for_message(message)\n01072|   local is_last_part = (last_part_id == part_id)\n01073|   local formatted = formatter.format_part(part, message, is_last_part)\n01074| \n01075|   M._replace_part_in_buffer(part_id, formatted)\n01076| end\n01077| \n01078| ---Event handler for focus changes\n01079| ---Re-renders part associated with current permission for displaying global shortcuts or buffer-local ones\n01080| function M.on_focus_changed()\n01081|   -- Check permission window first, fallback to state\n01082|   local current_permission = permission_window.get_all_permissions()[1]\n01083| \n01084|   if not current_permission then\n01085|     return\n01086|   end\n01087| \n01088|   M._rerender_part('permission-display-part')\n01089|   trigger_on_data_rendered()\n01090| end\n01091| \n01092| function M.on_session_changed(_, new, _)\n01093|   M.reset()\n01094|   if new then\n01095|     M.render_full_session()\n01096|   end\n01097| end\n01098| \n01099| ---Get all actions available at a specific line\n01100| ---@param line integer 0-indexed line number\n01101| ---@return table[] List of actions available at that line\n01102| function M.get_actions_for_line(line)\n01103|   return M._render_state:get_actions_at_line(line)\n01104| end\n01105| \n01106| ---Update display stats from a single message\n01107| ---@param message OpencodeMessage\n01108| function M._update_stats_from_message(message)\n01109|   if not state.current_model and message.info.providerID and message.info.providerID ~= '' then\n01110|     state.current_model = message.info.providerID .. '/' .. message.info.modelID\n01111|   end\n01112| \n01113|   local tokens = message.info.tokens\n01114|   if tokens and tokens.input > 0 then\n01115|     state.tokens_count = tokens.input + tokens.output + tokens.cache.read + tokens.cache.write\n01116|   end\n01117| \n01118|   if message.info.cost and type(message.info.cost) == 'number' then\n01119|     state.cost = message.info.cost\n01120|   end\n01121| end\n01122| \n01123| ---Get rendered message by ID\n01124| ---@param message_id string Message ID\n01125| ---@return RenderedMessage|nil Rendered message or nil if not found\n01126| function M.get_rendered_message(message_id)\n01127|   local rendered_msg = M._render_state:get_message(message_id)\n01128|   if rendered_msg then\n01129|     return rendered_msg\n01130|   end\n01131|   return nil\n01132| end\n01133| \n01134| return M\n01135| \n\n(End of file - total 1135 lines)\n</file>",
        "type": "text",
        "id": "prt_bfaa078ae001zhO39Uz3en7btW"
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "filename": "lua/opencode/ui/renderer.lua",
        "messageID": "msg_bfaa078a2001RUYhlKZhSlyWeF",
        "type": "file",
        "id": "prt_bfaa078ae002XvKak6z08HB5LV",
        "url": "file:///home/francis/Projects/_nvim/opencode.nvim/lua/opencode/ui/renderer.lua",
        "mime": "text/plain",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD"
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "messageID": "msg_bfaa078a2001RUYhlKZhSlyWeF",
        "text": "can you use the question tool and ask me a question with an other choice",
        "id": "prt_bfaa078a4001OxXpwZJxaFmqUo",
        "type": "text",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD"
      }
    }
  },
  {
    "type": "session.updated",
    "properties": {
      "info": {
        "directory": "/home/francis/Projects/_nvim/opencode.nvim",
        "version": "1.1.31",
        "slug": "calm-lagoon",
        "id": "ses_4055f967bffeIHf3DnP0xntmxD",
        "title": "New session - 2026-01-26T14:06:15.428Z",
        "projectID": "29d43526f88157cd4edd071b899dd01f240b771b",
        "time": { "created": 1769436375428, "updated": 1769436379349 }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.updated",
    "properties": {
      "info": {
        "path": {
          "root": "/home/francis/Projects/_nvim/opencode.nvim",
          "cwd": "/home/francis/Projects/_nvim/opencode.nvim"
        },
        "modelID": "gpt-4.1",
        "providerID": "github-copilot",
        "id": "msg_bfaa078e7001qc33BqBlqzHv8X",
        "agent": "build",
        "mode": "build",
        "tokens": { "reasoning": 0, "input": 0, "cache": { "read": 0, "write": 0 }, "output": 0 },
        "parentID": "msg_bfaa078a2001RUYhlKZhSlyWeF",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "role": "assistant",
        "cost": 0,
        "time": { "created": 1769436379367 }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.updated",
    "properties": {
      "info": {
        "time": { "created": 1769436379298 },
        "id": "msg_bfaa078a2001RUYhlKZhSlyWeF",
        "agent": "build",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "role": "user",
        "model": { "modelID": "gpt-4.1", "providerID": "github-copilot" },
        "summary": { "diffs": [] }
      }
    }
  },
  {
    "type": "session.updated",
    "properties": {
      "info": {
        "directory": "/home/francis/Projects/_nvim/opencode.nvim",
        "version": "1.1.31",
        "title": "New session - 2026-01-26T14:06:15.428Z",
        "slug": "calm-lagoon",
        "id": "ses_4055f967bffeIHf3DnP0xntmxD",
        "time": { "created": 1769436375428, "updated": 1769436379539 },
        "projectID": "29d43526f88157cd4edd071b899dd01f240b771b",
        "summary": { "deletions": 0, "files": 0, "additions": 0 }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "messageID": "msg_bfaa078e7001qc33BqBlqzHv8X",
        "id": "prt_bfaa07ecf0011yakDSUtAyStvx",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "type": "step-start",
        "snapshot": "56238d5c6bb499e9e265444377a201fba6b1a880"
      }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "id": "prt_bfaa07ed3001RYplcvPxb660OT",
        "type": "tool",
        "tool": "question",
        "state": { "raw": "", "status": "pending", "input": {} },
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "messageID": "msg_bfaa078e7001qc33BqBlqzHv8X",
        "callID": "call_IpPBuTk1riUXZDmDUDghZEpB"
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "question.asked",
    "properties": {
      "id": "que_bfaa0833a001jKE5x0BCsGLOYX",
      "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
      "questions": [
        {
          "header": "Favorite color",
          "question": "What is your favorite color?",
          "options": [
            { "label": "Red", "description": "The color red" },
            { "label": "Blue", "description": "The color blue" },
            { "label": "Other", "description": "Any color not listed" }
          ]
        }
      ],
      "tool": { "messageID": "msg_bfaa078e7001qc33BqBlqzHv8X", "callID": "call_IpPBuTk1riUXZDmDUDghZEpB" }
    }
  },
  {
    "type": "message.part.updated",
    "properties": {
      "part": {
        "id": "prt_bfaa07ed3001RYplcvPxb660OT",
        "type": "tool",
        "tool": "question",
        "state": {
          "status": "running",
          "input": {
            "questions": [
              {
                "header": "Favorite color",
                "question": "What is your favorite color?",
                "options": [
                  { "label": "Red", "description": "The color red" },
                  { "label": "Blue", "description": "The color blue" },
                  { "label": "Other", "description": "Any color not listed" }
                ]
              }
            ]
          },
          "time": { "start": 1769436382010 }
        },
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "messageID": "msg_bfaa078e7001qc33BqBlqzHv8X",
        "callID": "call_IpPBuTk1riUXZDmDUDghZEpB"
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "message.updated",
    "properties": {
      "info": {
        "time": { "created": 1769436379298 },
        "id": "msg_bfaa078a2001RUYhlKZhSlyWeF",
        "agent": "build",
        "sessionID": "ses_4055f967bffeIHf3DnP0xntmxD",
        "role": "user",
        "model": { "modelID": "gpt-4.1", "providerID": "github-copilot" },
        "summary": { "diffs": [], "title": "Question including Other option" }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] },
  {
    "type": "session.updated",
    "properties": {
      "info": {
        "directory": "/home/francis/Projects/_nvim/opencode.nvim",
        "version": "1.1.31",
        "title": "Question about opencode/ui/renderer.lua",
        "slug": "calm-lagoon",
        "id": "ses_4055f967bffeIHf3DnP0xntmxD",
        "time": { "created": 1769436375428, "updated": 1769436379539 },
        "projectID": "29d43526f88157cd4edd071b899dd01f240b771b",
        "summary": { "deletions": 0, "files": 0, "additions": 0 }
      }
    }
  },
  { "type": "custom.emit_events.finished", "properties": [] }
]
